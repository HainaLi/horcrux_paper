\section{Security Analysis} \label{design_security_analysis}
%The client side should have two components:
%- Trusted component: obtains MP, stores AuthKey, intercepts network requests to find dummy U/PW, obtains password shares and reconstructs PW, replaces in outgoing traffic.  This should be the small component that can be audited (e.g., we should have the lines of code, and ideally the entire code short enough to put in appendix).
%- Untrusted component: scans pages for logins, auto-fills in dummy u/pw in those forms, etc.  This has most of the complex UI code, but doesn't need to be trusted since it has no access to any sensitive data.  It may need access to the list of sites with stored passwords, but shouldn't have access to anything else.

%\SecPass\ is a prototype of the ideas presented and tested in this paper; without official security auditing, we assume it is not suitable for commercial distribution. 

\SecPass\ is designed to provide strong protection of user credentials against the realistic threat model described in Section~\ref{sec:threat_model}. Here, we analyze how well it resists both client-side (Section~\ref{sec:client_side_security_analysis}) and server-side (Section~\ref{server_analysis}) adversaries.

\subsection{Client Security} \label{sec:client_side_security_analysis}

\SecPass's overriding design goals are to minimize attack surface and decentralize trust as much as possible. To achieve this goal, \SecPass\ is split into two components, a trusted component that has access to the user's entered master password and secrets derived from it and obtained from the keystores using credentials obtained from the master password, and an untrusted component that manages the user interface and everything else that does not involve any sensitive data.  The main strategies to minimize the client-side attack surface are to limit the window of opportunity for an attacker to steal the login credentials and to make the client code that has access to the master password as small and simple as possible so that it may be realistically audited.  The entire code for the trusted component is around 800 non-comment lines of JavaScript. %\dnote{is this still true with cuckoo hashing?} \hnote{the cuckoo hashing greatly increased our lines of code}

\shortsection{Password Exposure}
%As mentioned in Section \ref{sec:threat_model}, our threat model focuses on network attacks through which the username and password are stolen from the form after it is autofilled onto a web page. \SecPass\ also prevents attacks that attempt to steal the password by changing the destination of the request and those that exfiltrate many passwords at the once in a sweep attack. The vector for these attacks is injecting a script to modify a page used by the victim by tampering with the network traffic. 
Because the password is never inserted into the DOM, it is not vulnerable to injected scripts. Password managers that reveal the real credentials earlier in the process are limited to checking the form action at the time of the autofill, so could be vulnerable to scripts that dynamically modify the form action after the password has been provided. \SecPass\ ensures that the password is only ever sent to the correct domain by checking the URL in the POST request in the intercepted network traffic.  The request must use HTTPS, so this ensures (assuming the browser verifies HTTPS certificates and implements TLS correctly) that the real credentials will only ever be inserted into an outgoing network request to the intended domain.  

%Also, checking the action of the form does not secure web forms that do not have a form action and are driven by JavaScript instead. This accounts for 10\% of the login forms in our compatibility tests  (Section~\ref{sec:compatibility}). \SecPass\ never exposes any credentials to the DOM, so any client-side script attack that depends on reading or modifying the DOM is thwarted.

\shortsection{Resisting Guessing Attacks on Master Password}
An adversary who compromises the client's host may be able to obtain the \keyword{config.json} file that contains keystore credentials encrypted with a key derived from the user's master password.  This file may also be exposed when a user moves it to setup a new device. As discussed in Section~\ref{protocol_setup}, \SecPass\ derives an encryption key from the master password using a password-based key Derivation Function (\keyword{PBKDF2}) over 100,000 iterations. This limits the number of guessing attempts an adversary could make, but a sufficiently resourceful adversary could still be able to execute an effective dictionary attack against a weak master password. Since the user-selected master password may be weak, it is important that there is no way for 
an adversary to do an off-line dictionary attack against it. There should be no way  for the adversary to check if a guessed master password is correct without sending a request 
to an external service such as an attempt to authenticate with a keystore server. We ensure this by being careful to never encrypt anything with keys derived from the master password that is distinguishable from randomness to an off-line adversary. An adversary can only 
verify their guess on the master password by deriving the key, using it to decrypt access  credentials, and performing an online query with the credentials. The access credentials are 
random bit strings, so an adversary cannot determine if a guess on the master password is 
successful without submitting those credentials to a guessed keystore server. This is slow and expensive, and also subject to methods the keystore server should use to limit the number of inauthentic requests attempted (i.e., ``throttling''). Neither Amazon nor Microsoft makes these mechanisms public, but at worst, they are no more than the limits for regular requests. AWS limits the steady-state request rates to 1000 requests per second using the token bucket algorithm~\cite{AWSthrottle}; Azure limits read requests to 15,000 per hour and write requests to 1,200 per hour~\cite{Azurethrottle}. 
%\dnote{surely they have stronger limits on authentication attempts?}

\shortsection{Security Limitations to a Firefox Add-on}
Browsers add-ons naturally limit the attack surface by isolating the higher privileged \Core\ from the \UI~\cite{barth2010protecting}. Because the \UI\ runs in an insecure environment, the web pages, they are exposed to more threats despite the fact that each script running on the page can only access its own variables. Cross-extension attacks~\cite{buyukkayhan2016crossfire} exploit add-ons that have not properly defined its namespace. When a malicious add-ons is using the same JavaScript namespace of a benign add-ons, it can access and modify all of the benign add-on's global variables, functions, and objects. Recently, LastPass reported that it had updated its non-mobile browser extensions to fix this vulnerability, which allowed a clever attacker to force the LastPass extension to reveal stored user data~\cite{LastpassSecurityUpdated}. We are aware of the threat that cross-extension poses to \SecPass\ and avoid using global variables, functions, and objects.

As an add-on subjected to the limitations of Firefox's API, our prototype \SecPass\ implementation intercepts and changes the network traffic using the same methods available to other add-ons. Since Firefox does not have a
specific resolution for conflicts between different add-ons, it is not determined which add-on will have the last opportunity to view and edit the request.  Another add-on with traffic interception capabilities that  executes after \SecPass, would be able to read the final version of the POST request which includes the real credentials.  This is serious risk, but mitigated by the user interactions needed to install an add-on. In February 2015, Mozilla made it more difficult for attackers to run malicious add-ons by only allowing reviewed and signed add-ons to run on browsers~\cite{mozilla_review_policies}. This security feature, however, could be turned off by the user, and an insufficiently paranoid user could be tricked into installing a malicious add-on. Section~\ref{sec:discussion} discusses ways \SecPass\ could be deployed.
%See the discussion on the deprecating Firefox add-on and recommended integration into the Firefox browser. 
%\dnote{do we have a discussion elsewhere about what actual implementation should be?} \hnote{mentioned in the discussion. Though, not in detail about how exactly to change the Firefox browser.}

\subsection{Server Security} \label{server_analysis}
\SecPass\ is designed to avoid trusting any single keystore. Here we consider the risks if a single keystore is compromised, and if all of the user's keystores are compromised.

\shortsection{Single Keystore Compromise}
If an adversary obtains the complete keystore database from one of the keystores (or several of the keystores, up to the secret sharing threshold), they learn no semantic information other than its size if the user's keystore has expanded beyond the default size. The secret-sharing mechanism means that a single share provides no semantic information. Up to the threshold limit number of keystores may be fully compromised without any loss of credentials.
Because of the way we use cuckoo hashing and fill all entries of the table with shares which will appear indistinguishable to an adversary, there is no way for an adversary to tell with entries in the table correspond to real accounts. This prevents a guessing attack on master password with popular domains, since all possible guesses lead to an indistinguishable set of possible locations. 

Our design does not hide the access pattern, however. This means an adversary who can observe unencrypted requests to the keystore over time (e.g., the keystore operator itself, or an adversary that compromises a keystore server without detection and maintains a monitor there) would be able to learn common patterns of requests. Such an adversary could perform a guessing attack on the master password with common domains, to look for sets of locations that match the requests. Hiding this access pattern would either require giving up on domain privacy (so the domain is no longer encrypted with the master password, but revealed in cleartext in the keystore request), or using expensive methods such as Oblivious RAM~\cite{goldreich96} to hide access patterns.

%This threat requires that the traffic to the keystores are unencrypted, and we cannot design a secure password manager without assuming traffic encryption. \dnote{can we say anything about why this isn't serious?} \hnote{Though my explanation doesn't cover why attacking a monitor to the keystores isn't serious}

The secret sharing schemes we use are malleable, so an adversary who has complete access to a user's keystore could modify their passwords and credentials (with XOR-secret-sharing this is simple bit flipping; with Shamir-sharing it is more difficult to do in a predictable way). This could prevent users from being able to obtain their passwords, but is not a threat to confidentiality.

\shortsection{Multiple Keystore Compromise} If all the user's keystores are fully compromised, the adversary can reconstruct the users' encrypted passwords. This seems unlikely to happen from vulnerabilities or insider threats if the user has keystores operated by different cloud services, but may be a risk under subpoena threats (users paranoid about NSLs or subpoenas will want to choose the jurisdictions of their keystores accordingly). %Even if the attacker manages to steal every keystore, each of the shares are individually encrypted with the key derived from the master password. In this case, it is not possible to mount a dictionary attack to shares of the username and password because they do not resemble words. 
Each password is encrypted with the master-password derived key before sharing it; the adversary would still need to do a dictionary attack on the master password to obtain the user's password. 

%\dnote{this seems out of place and repetitive here (maybe hasn't been updated?)}
%\shortsection{Domain and Username Privacy} \label{domain_privacy}
%An adversary who manages to compromise one keystore will learn the domains for with the user has stored credentials. 
%In order to store domains and usernames in a privacy-preserving manner, 
%\SecPass\ ensures that an adversary obtaining one keystore would not be able to decrypt the domains and usernames through off-line dictionary attacks against the master password. Using another source of entropy to encrypt the domains would work, but would either require the user to remember a second password or depend on some key stored on the user's client which would make setting up new devices more difficult.

%This means they cannot be directly encrypted with a key derived from the master password without increasing the risk that an adversary who obtains both the client's configuration file and a keystore compromise would be able to do an off-line dictionary attack against the master password.  

%Instead, we use a variant of cuckoo hashing along with secret sharing to ensure that the privacy of the domain and username are preserved. Since the sets of domains is small, the resulting table key on the server should be equally likely to appear as the output of $H\left(d, enc\_key\right)$ and $H\left(d, enc\_key*\right)$, where $enc\_key$ is the real encryption key and $enc\_key*$ is the wrong guess. In our design, every guess of the $enc\_key$ yields an indistinguishable row of shares. Without stealing every database and combining the shares, the attacker has no way of distinguishing the table keys storing real credentials from random noise.  