\section{Context}\label{sec:vulnerabilities}

This section provides background on vulnerabilities in current password manager designs and implementations, and presents the threat model that drives our design decisions.

\subsection{Password Manager Vulnerabilities}

We divide password manager vulnerabilities into client-side vulnerabilities, where the adversary is able to compromise the client or its network connection, and server-side vulnerabilities, where the adversary compromises the password store.

\shortsection{Client Vulnerabilities} Major password managers autofill user credentials into authentication forms found on visited webpages. This exposes those credentials to the DOM, where they are visible to injected malicious scripts~\cite{Silver2014,Li2014,Stock2014} that can read the form using \keyword{Element.value}. This returns the string currently present in an input field, even if it is a password type field that displays as asterisks. Any value filled in by the password manager or typed in by the user can be stolen by the script.  The dynamic nature of JavaScript means functions used in the password manager code may be replaced by adversaries.  Li et al.\ found that all three of the tested password managers that supported bookmarklets were vulnerable to these kinds of vulnerabilities~\cite{Li2014}. Silver et al.\ examined the autofill policies of 15 password managers and found that all %\dnote{or some? how many? what was there was ambiguous} \hnote{See the next sentence for a more detailed explanation.} 
had followed some unsafe practices with the security of their autofill policies~\cite{Silver2014}. None of the password managers comprehensively checked whether the protocol and action of the login form are secure before autofilling the credentials, making the credentials susceptible to being sent to a different destination or through an insecure protocol (HTTP). This risk may be exacerbated by autofill policies that autofill without any user interaction required, allowing attackers to obtain credentials from a large number of domains through an access point.

Password manager clients are also vulnerable because of implementation bugs, particularly in complex URL parsing code. In 2016, Karlsson~\cite{URLParsingBug} detected a bug in the Lastpass client script code that treated the wrong part of the URL as the domain, which allowed an attacker to fool the LastPass browser extension into providing a user's credentials for any stored domain.  This motivates our design to separate the complex UI code from the small trusted core.

%\dnote{the rest of this paragraph is confused - I thought there was a parsing bug that made it possible for adversary to send passwords to wrong site? the domain privacy issue is separate from this} \hnote{After reading the cited article, I think this paragraph describes the issue perfectly. Perhaps you're thinking of another article?}
%\dnote{this is the one I have in mind: https://labs.detectify.com/2016/07/27/how-i-made-lastpass-give-me-all-your-passwords/ (this was actually the article that prompted suggesting the secret-shared password store)}
%In January 2017, a URL parsing bug was discovered in the vault design of LastPass~\cite{hackernoon2017}. The password manager offered the convenience of showing a user all of the domains which they hold accounts for in the web view of their vault. By inspecting local parameters in the browser, it was evident that LastPass does not provide privacy over the domain names of accounts a user has credentials for -- the domain names were simply encoded as hexadecimal strings.  We discuss domain privacy further in Section~\ref{domain_privacy}.

%\shortsection{Password Syncing} \label{password_syncing} Many password managers sync passwords across devices but does not implement authorization and credential sharing policies correctly. Li et al.~\cite{Li2014} surveyed 5 password managers and found that 2 of them suffer from authorization vulnerabilities. Through this type of attack, an adversary can access Alice's credentials through a device that she has never used. 

%\subsubsection{Script Attacks} \label{script_attacks}
%Even when password managers implement all the mistakes listed in Section~\ref{native_password_manager_vulnerabilities} correctly, the current design choice does not protect the credentials from a network attacker capable of injecting scripts onto a page. This type of attack was described in depth by~\cite{Li2014,Silver2014,Stock2014}. If the real credentials appear on the page at any point, it is susceptible to a prepared attack. The attacker only needs to figure out when to read the {\tt{Element.value}} to fetch the real password 


%Autofill policies vary, but password managers typically check the domain and path to grab the credentials for the correct website, fill the credentials in through JavaScript or keystrokes~\cite{keepass}, and sometimes even submit the form for the user. 


%A more secure password manager would distinguish between different paths and subdomains hosted on the same domain, whether the form is visible, and whether the form is loaded and submitted through HTTPS protocol~\cite{Silver2014}. As demonstrated by Silver et al., this convenience opens up a myriad of opportunities for an attacker to steal the sensitive information right off the browser through scripts~\cite{Silver2014}.

%Our solution, as described later in section [reference], keeps the autofill feature but protects the credentials from being stolen. This technique only applies to web-based password managers, though the idea could be applied to any unprotected form. 


\shortsection{Server Vulnerabilities} \label{password_storage_vulnerability}
Password managers can store credentials either in the cloud or locally on the user's computer. Using local storage eliminates the need to trust an external provider, but means that it is now up to the user (who lacks the physical and technical resources of a cloud provider with a data center) to protect the store, and that there is no way to share credentials across multiple devices.  It also means that an attacker who can compromise the user's device would now have access to both the password client and store.  Although our design allows for the storage devices to include a mix of user-hosted or local stores, for nearly all users, we expect it is a better option to outsource storage to cloud providers.

Users who store their credentials in the cloud or user-hosted platforms inherit the risk of server-side compromises. Unlike a locally stored password database, an adversary could mount an attack on such servers from anywhere and attempt to steal their data, as happened to LastPass in 2015~\cite{lastpasshack}. These thefts typically expose encrypted versions of users passwords, URLs, and emails for all of their online accounts, which are open to thieves to attempt to decrypt offline. Notably, the LastPass server compromise included leakage of a cryptographic hash of many users masters passwords, which was used to decrypt their sensitive online account login information. Modern password managers seek to mitigate offline attacks by storing encrypted passwords using intentionally slow key derivation functions that amplify the cost of a dictionary attack.  Currently, in 2017, it is much more common for password managers to never store the user's master password on any device, and instead rely on the key derivations from the user's master password and other local secrets to decrypt passwords on the servers. %\dnote{aren't these used to decrypt to passwords stored by the server?} yes

% Dave - I moved cuckoo hashing section from here (doesn't belong in context)

\subsection{Threat Model}\label{sec:threat_model}

Our focus is on mitigating the risks posed by motivated and capable adversaries who can inject scripts into trusted web pages, compromise the client's network access, and may be able to compromise a server database to acquire a full copy of its contents.

\shortsection{Client Side} We assume the adversary can inject scripts into any visited webpage, including pages delivered using HTTPS. This covers the possibility of script injection vulnerabilities in the trusted website, as well as wireless access point attacks, both of which we consider realistic threats. 

We consider stronger client-side attackers out of scope, since they have so many other ways to victimize the user.  An adversary who can compromise the client's browser to access its internal state (for example, by exploiting a memory corruption vulnerability in the browser to executed arbitrary code with a ROP attack) can extract secrets from anywhere in the browser's memory, and can generate authentic-looking dialog boxes to request the master password from the user.  Similarly, an attacker with a root-level compromise of the client's system, can install a keylogger or alter the clients certificate store to spoof HTTPS connections to targeted sites.  No password manager design can provide strong defenses to compromises at those levels. Hence, we consider the web browser and host operating system to be a trusted computing base.  

We also do not address client attacks that exploit vulnerable pages on the target server. For example, if the server domain hosts a login with an open redirect or a XSS vulnerability where the attacker is able to adjust the URL path to send the credentials to a compromised page on the server's site that will resend the submitted password to another site owned by the attacker. The only way to prevent this type of attack would be through requiring the entire URL path to match the enrolled path, not just the domain. Enforcing a specific path may break many websites that dynamically generate their target URLs. In this respect, Horcrux is not more vulnerable than traditional password managers or manual input of credentials by a user.  

We do not consider social engineering or interface spoofing attacks where victims would be tricked into entering their master password into a rogue dialog box or directly providing their unencrypted credentials to an adversary's site.  The lack of trusted input paths in commonly-used computing systems is an important problem and serious threat, but outside the scope of this work.  As discussed further in Section~\ref{sec:client_side_security_analysis}, our prototype implementation also assumes the user will not be tricked into installing a malicious add-on that can observe network traffic after the password manager add-on has inserted the real password (this is necessary for our prototype because of limitations in Firefox's extension mechanism, but would not be an issue for a password manager built into a browser or mobile OS).

\shortsection{Server Side}
For the server side, we include the threat of full release of all data stored by a cloud server. This could happen as the result of a server vulnerability~\cite{gasti2012security}, insider attack from a cloud service employee, or the cloud service complying with a subpoena or national security letter.  Hence, it is important that the data stored by the cloud servers is not vulnerable to an offline guessing attack on the master password. This leads to a design objective that everything encrypted with keys derived from the master password must be indistinguishable to an attacker so there is no way to determine if a guess is correct.

Finally, we assume the user should not have any intrinsic trust in the provider of the password manager. This means we want a design where the code that has access to sensitive data is as small and simple as possible, to make individual or third-party auditing realistic. 

